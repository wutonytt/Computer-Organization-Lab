$date
	Wed May 13 01:24:42 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module TestBench $end
$scope module cpu $end
$var wire 1 ! clk_i $end
$var wire 1 " rst_i $end
$var wire 1 # zero $end
$var wire 32 $ operand2 [31:0] $end
$var wire 32 % instr [31:0] $end
$var wire 32 & Shift_o [31:0] $end
$var wire 32 ' SE_o [31:0] $end
$var wire 1 ( RegWrite $end
$var wire 1 ) RegDst $end
$var wire 32 * RTdata [31:0] $end
$var wire 32 + RSdata [31:0] $end
$var wire 5 , RDaddr [4:0] $end
$var wire 32 - PC_plus_4 [31:0] $end
$var wire 32 . PC_o [31:0] $end
$var wire 32 / PC_i [31:0] $end
$var wire 32 0 PC_Branch [31:0] $end
$var wire 1 1 Branch $end
$var wire 32 2 ALU_result [31:0] $end
$var wire 3 3 ALU_op [2:0] $end
$var wire 1 4 ALUSrc $end
$var wire 4 5 ALUCtrl [3:0] $end
$scope module AC $end
$var wire 6 6 funct_i [5:0] $end
$var wire 3 7 ALUOp_i [2:0] $end
$var reg 4 8 ALUCtrl_o [3:0] $end
$upscope $end
$scope module ALU $end
$var wire 4 9 ctrl_i [3:0] $end
$var wire 5 : shamt [4:0] $end
$var wire 1 # zero_o $end
$var wire 32 ; src2_i [31:0] $end
$var wire 32 < src1_i [31:0] $end
$var reg 32 = result_o [31:0] $end
$upscope $end
$scope module Adder1 $end
$var wire 32 > src2_i [31:0] $end
$var wire 32 ? sum_o [31:0] $end
$var wire 32 @ src1_i [31:0] $end
$upscope $end
$scope module Adder2 $end
$var wire 32 A src1_i [31:0] $end
$var wire 32 B sum_o [31:0] $end
$var wire 32 C src2_i [31:0] $end
$upscope $end
$scope module Decoder $end
$var wire 6 D instr_op_i [5:0] $end
$var reg 1 4 ALUSrc_o $end
$var reg 3 E ALU_op_o [2:0] $end
$var reg 1 1 Branch_o $end
$var reg 1 ) RegDst_o $end
$var reg 1 ( RegWrite_o $end
$upscope $end
$scope module IM $end
$var wire 32 F pc_addr_i [31:0] $end
$var reg 32 G instr_o [31:0] $end
$var integer 32 H i [31:0] $end
$upscope $end
$scope module Mux_ALUSrc $end
$var wire 1 4 select_i $end
$var wire 32 I data1_i [31:0] $end
$var wire 32 J data0_i [31:0] $end
$var reg 32 K data_o [31:0] $end
$upscope $end
$scope module Mux_PC_Source $end
$var wire 32 L data0_i [31:0] $end
$var wire 32 M data1_i [31:0] $end
$var wire 1 N select_i $end
$var reg 32 O data_o [31:0] $end
$upscope $end
$scope module Mux_Write_Reg $end
$var wire 5 P data0_i [4:0] $end
$var wire 5 Q data1_i [4:0] $end
$var wire 1 ) select_i $end
$var reg 5 R data_o [4:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk_i $end
$var wire 32 S pc_in_i [31:0] $end
$var wire 1 " rst_i $end
$var reg 32 T pc_out_o [31:0] $end
$upscope $end
$scope module RF $end
$var wire 5 U RDaddr_i [4:0] $end
$var wire 32 V RDdata_i [31:0] $end
$var wire 5 W RSaddr_i [4:0] $end
$var wire 32 X RSdata_o [31:0] $end
$var wire 5 Y RTaddr_i [4:0] $end
$var wire 32 Z RTdata_o [31:0] $end
$var wire 1 ( RegWrite_i $end
$var wire 1 ! clk_i $end
$var wire 1 " rst_i $end
$upscope $end
$scope module SE $end
$var wire 16 [ data_i [15:0] $end
$var reg 32 \ data_o [31:0] $end
$upscope $end
$scope module Shifter $end
$var wire 32 ] data_i [31:0] $end
$var reg 32 ^ data_o [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
xN
bx M
bx L
bx K
bx J
bx I
b100000 H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
b100 >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
x4
bx 3
bx 2
x1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
x)
x(
bx '
bx &
bx %
bx $
x#
0"
0!
$end
#5
b1000 0
b1000 B
b1000 M
b100 &
b100 C
b100 ^
b1000 /
b1000 O
b1000 S
1N
b0 ,
b0 R
b0 U
b0 $
b0 ;
b0 K
1#
b1 '
b1 I
b1 \
b1 ]
b1010 5
b1010 8
b1010 9
11
0)
04
b101 3
b101 7
b101 E
0(
b1 2
b1 =
b1 V
b0 :
b1 [
b1 6
b101 D
b0 *
b0 J
b0 Z
b0 Y
b1 +
b1 <
b1 X
b1 W
b0 Q
b0 P
b10100001000000000000000000001 %
b10100001000000000000000000001 G
b100 -
b100 ?
b100 A
b100 L
b0 .
b0 @
b0 F
b0 T
1!
#10
0!
1"
#15
b1110000000011100 &
b1110000000011100 C
b1110000000011100 ^
0#
0N
b11100000000111 '
b11100000000111 I
b11100000000111 \
b11100000000111 ]
b1000 5
b1000 8
b1000 9
01
1)
b10 3
b10 7
b10 E
1(
b111 $
b111 ;
b111 K
b111 ,
b111 R
b111 U
b11100000000111 [
b111 6
b0 D
b111 *
b111 J
b111 Z
b111 Y
b10 +
b10 <
b10 X
b10 W
b111 Q
b111 P
b1100 /
b1100 O
b1100 S
b10001110011100000000111 %
b10001110011100000000111 G
b1110000000101000 0
b1110000000101000 B
b1110000000101000 M
b1100 -
b1100 ?
b1100 A
b1100 L
b1000 .
b1000 @
b1000 F
b1000 T
1!
#20
0!
#25
b0 &
b0 C
b0 ^
b0 '
b0 I
b0 \
b0 ]
b0 ,
b0 R
b0 U
1#
b0 [
b0 6
b0 Y
b0 +
b0 <
b0 X
b0 W
b0 Q
b0 P
b0 2
b0 =
b0 V
b10000 /
b10000 O
b10000 S
b0 %
b0 G
b0 $
b0 ;
b0 K
b10000 0
b10000 B
b10000 M
b10000 -
b10000 ?
b10000 A
b10000 L
b1100 .
b1100 @
b1100 F
b1100 T
b0 *
b0 J
b0 Z
1!
#30
0!
#35
b10100 /
b10100 O
b10100 S
b10100 0
b10100 B
b10100 M
b10100 -
b10100 ?
b10100 A
b10100 L
b10000 .
b10000 @
b10000 F
b10000 T
1!
#40
0!
#45
b11000 /
b11000 O
b11000 S
b11000 0
b11000 B
b11000 M
b11000 -
b11000 ?
b11000 A
b11000 L
b10100 .
b10100 @
b10100 F
b10100 T
1!
